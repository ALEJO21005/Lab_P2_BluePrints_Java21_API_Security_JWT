<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/README.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/README.md" />
              <option name="originalContent" value="# Escuela Colombiana de Ingeniería Julio Garavito&#10;## Arquitectura de Software – ARSW&#10;### Laboratorio – Parte 2: BluePrints API con Seguridad JWT (OAuth 2.0)&#10;&#10;Este laboratorio extiende la **Parte 1** ([Lab_P1_BluePrints_Java21_API](https://github.com/DECSIS-ECI/Lab_P1_BluePrints_Java21_API)) agregando **seguridad a la API** usando **Spring Boot 3, Java 21 y JWT (OAuth 2.0)**.  &#10;El API se convierte en un **Resource Server** protegido por tokens Bearer firmados con **RS256**.  &#10;Incluye un endpoint didáctico `/auth/login` que emite el token para facilitar las pruebas.&#10;&#10;---&#10;&#10;## Objetivos&#10;- Implementar seguridad en servicios REST usando **OAuth2 Resource Server**.&#10;- Configurar emisión y validación de **JWT**.&#10;- Proteger endpoints con **roles y scopes** (`blueprints.read`, `blueprints.write`).&#10;- Integrar la documentación de seguridad en **Swagger/OpenAPI**.&#10;&#10;---&#10;&#10;## Requisitos&#10;- JDK 21&#10;- Maven 3.9+&#10;- Git&#10;&#10;---&#10;&#10;## Ejecución del proyecto&#10;1. Clonar o descomprimir el proyecto:&#10;   ```bash&#10;   git clone https://github.com/DECSIS-ECI/Lab_P2_BluePrints_Java21_API_Security_JWT.git&#10;   cd Lab_P2_BluePrints_Java21_API_Security_JWT&#10;   ```&#10;   ó si el profesor entrega el `.zip`, descomprimirlo y entrar en la carpeta.&#10;&#10;2. Ejecutar con Maven:&#10;   ```bash&#10;   mvn -q -DskipTests spring-boot:run&#10;   ```&#10;&#10;3. Verificar que la aplicación levante en `http://localhost:8080`.&#10;&#10;---&#10;&#10;## Endpoints principales&#10;&#10;### 1. Login (emite token)&#10;```&#10;POST http://localhost:8080/auth/login&#10;Content-Type: application/json&#10;&#10;{&#10;  &quot;username&quot;: &quot;student&quot;,&#10;  &quot;password&quot;: &quot;student123&quot;&#10;}&#10;```&#10;Respuesta:&#10;```json&#10;{&#10;  &quot;access_token&quot;: &quot;eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9...&quot;,&#10;  &quot;token_type&quot;: &quot;Bearer&quot;,&#10;  &quot;expires_in&quot;: 3600&#10;}&#10;```&#10;&#10;### 2. Consultar blueprints (requiere scope `blueprints.read`)&#10;```&#10;GET http://localhost:8080/api/blueprints&#10;Authorization: Bearer &lt;ACCESS_TOKEN&gt;&#10;```&#10;&#10;### 3. Crear blueprint (requiere scope `blueprints.write`)&#10;```&#10;POST http://localhost:8080/api/blueprints&#10;Authorization: Bearer &lt;ACCESS_TOKEN&gt;&#10;Content-Type: application/json&#10;&#10;{&#10;  &quot;name&quot;: &quot;Nuevo Plano&quot;&#10;}&#10;```&#10;&#10;---&#10;&#10;## Swagger UI&#10;- URL: [http://localhost:8080/swagger-ui/index.html](http://localhost:8080/swagger-ui/index.html)&#10;- Pulsa **Authorize**, ingresa el token en el formato:&#10;  ```&#10;  Bearer eyJhbGciOi...&#10;  ```&#10;&#10;---&#10;&#10;## Estructura del proyecto&#10;```&#10;src/main/java/co/edu/eci/blueprints/&#10;  ├── api/BlueprintController.java       # Endpoints protegidos&#10;  ├── auth/AuthController.java           # Login didáctico para emitir tokens&#10;  ├── config/OpenApiConfig.java          # Configuración Swagger + JWT&#10;  └── security/&#10;       ├── SecurityConfig.java&#10;       ├── MethodSecurityConfig.java&#10;       ├── JwtKeyProvider.java&#10;       ├── InMemoryUserService.java&#10;       └── RsaKeyProperties.java&#10;src/main/resources/&#10;  └── application.yml&#10;```&#10;&#10;---&#10;&#10;## Actividades propuestas&#10;1. Revisar el código de configuración de seguridad (`SecurityConfig`) e identificar cómo se definen los endpoints públicos y protegidos.&#10;2. Explorar el flujo de login y analizar las claims del JWT emitido.&#10;3. Extender los scopes (`blueprints.read`, `blueprints.write`) para controlar otros endpoints de la API, del laboratorio P1 trabajado.&#10;4. Modificar el tiempo de expiración del token y observar el efecto.&#10;5. Documentar en Swagger los endpoints de autenticación y de negocio.&#10;&#10;---&#10;# REPORTE DE LABORATORIO&#10;---&#10;### INTEGRANTES:&#10;      - Laura Alejandra Venegas Piraban  &#10;      - Sergio Alejandro Idarraga Torres  &#10;&#10;## 1. Código de configuración de seguridad&#10;En el archivo `SecurityConfig.java`, se define la configuración de seguridad para la API. Se especifica que el endpoint `/auth/login` es público, mientras que los endpoints bajo `/api/**&#10;requieren autenticación. Además, se configura el Resource Server para validar tokens JWT firmados con RS256.&#10;&#10;&lt;div align=&quot;center&quot;&gt;&#10;  &lt;img src=&quot;img/filterChain.png&quot; alt=&quot;filterChain&quot; style=&quot;max-width: 400px; display: block; margin: 0 auto;&quot; /&gt;&#10;&lt;/div&gt;&#10;&#10;Con la función 'filterchain' se configuran las rutas y los permisos y aquí es donde se definen las reglas de tráfico que queremos que este en nuestra API.&#10;```http.csrf(csrf -&gt; csrf.disable())``` este fragmento de código se encarga de deshabilitar la protección contra ataques CSRF, lo cual es común en APIs RESTful que no mantienen estado.  &#10;```.authorizeHttpRequests(auth -&gt; auth.requestMatchers (&quot;/actuator/health&quot;, &quot;/auth/login&quot;).permitAll()&#10;``` esta parte del código define que el endpoint `/auth/login` es accesible para todos sin necesidad de autenticación, mientras que cualquier otra solicitud requiere que el usuario esté autenticado.  &#10;```oauth2ResourceServer(OAuth2ResourceServerConfigurer::jwt)``` esta línea configura la aplicación como un Resource Server que utiliza JWT para la autenticación y autorización.&#10;&#10;---&#10;&#10;## Lecturas recomendadas&#10;- [Spring Security Reference – OAuth2 Resource Server](https://docs.spring.io/spring-security/reference/servlet/oauth2/resource-server/index.html)&#10;- [Spring Boot – Securing Web Applications](https://spring.io/guides/gs/securing-web/)&#10;- [JSON Web Tokens – jwt.io](https://jwt.io/introduction)&#10;&#10;---&#10;&#10;## Licencia&#10;Proyecto educativo con fines académicos – Escuela Colombiana de Ingeniería Julio Garavito.&#10;" />
              <option name="updatedContent" value="# Escuela Colombiana de Ingeniería Julio Garavito&#10;## Arquitectura de Software – ARSW&#10;### Laboratorio – Parte 2: BluePrints API con Seguridad JWT (OAuth 2.0)&#10;&#10;Este laboratorio extiende la **Parte 1** ([Lab_P1_BluePrints_Java21_API](https://github.com/DECSIS-ECI/Lab_P1_BluePrints_Java21_API)) agregando **seguridad a la API** usando **Spring Boot 3, Java 21 y JWT (OAuth 2.0)**.  &#10;El API se convierte en un **Resource Server** protegido por tokens Bearer firmados con **RS256**.  &#10;Incluye un endpoint didáctico `/auth/login` que emite el token para facilitar las pruebas.&#10;&#10;---&#10;&#10;## Objetivos&#10;- Implementar seguridad en servicios REST usando **OAuth2 Resource Server**.&#10;- Configurar emisión y validación de **JWT**.&#10;- Proteger endpoints con **roles y scopes** (`blueprints.read`, `blueprints.write`).&#10;- Integrar la documentación de seguridad en **Swagger/OpenAPI**.&#10;&#10;---&#10;&#10;## Requisitos&#10;- JDK 21&#10;- Maven 3.9+&#10;- Git&#10;&#10;---&#10;&#10;## Ejecución del proyecto&#10;1. Clonar o descomprimir el proyecto:&#10;   ```bash&#10;   git clone https://github.com/DECSIS-ECI/Lab_P2_BluePrints_Java21_API_Security_JWT.git&#10;   cd Lab_P2_BluePrints_Java21_API_Security_JWT&#10;   ```&#10;   ó si el profesor entrega el `.zip`, descomprimirlo y entrar en la carpeta.&#10;&#10;2. Ejecutar con Maven:&#10;   ```bash&#10;   mvn -q -DskipTests spring-boot:run&#10;   ```&#10;&#10;3. Verificar que la aplicación levante en `http://localhost:8080`.&#10;&#10;---&#10;&#10;## Endpoints principales&#10;&#10;### 1. Login (emite token)&#10;```&#10;POST http://localhost:8080/auth/login&#10;Content-Type: application/json&#10;&#10;{&#10;  &quot;username&quot;: &quot;student&quot;,&#10;  &quot;password&quot;: &quot;student123&quot;&#10;}&#10;```&#10;Respuesta:&#10;```json&#10;{&#10;  &quot;access_token&quot;: &quot;eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9...&quot;,&#10;  &quot;token_type&quot;: &quot;Bearer&quot;,&#10;  &quot;expires_in&quot;: 3600&#10;}&#10;```&#10;&#10;### 2. Consultar blueprints (requiere scope `blueprints.read`)&#10;```&#10;GET http://localhost:8080/api/blueprints&#10;Authorization: Bearer &lt;ACCESS_TOKEN&gt;&#10;```&#10;&#10;### 3. Crear blueprint (requiere scope `blueprints.write`)&#10;```&#10;POST http://localhost:8080/api/blueprints&#10;Authorization: Bearer &lt;ACCESS_TOKEN&gt;&#10;Content-Type: application/json&#10;&#10;{&#10;  &quot;name&quot;: &quot;Nuevo Plano&quot;&#10;}&#10;```&#10;&#10;---&#10;&#10;## Swagger UI&#10;- URL: [http://localhost:8080/swagger-ui/index.html](http://localhost:8080/swagger-ui/index.html)&#10;- Pulsa **Authorize**, ingresa el token en el formato:&#10;  ```&#10;  Bearer eyJhbGciOi...&#10;  ```&#10;&#10;---&#10;&#10;## Estructura del proyecto&#10;```&#10;src/main/java/co/edu/eci/blueprints/&#10;  ├── api/BlueprintController.java       # Endpoints protegidos&#10;  ├── auth/AuthController.java           # Login didáctico para emitir tokens&#10;  ├── config/OpenApiConfig.java          # Configuración Swagger + JWT&#10;  └── security/&#10;       ├── SecurityConfig.java&#10;       ├── MethodSecurityConfig.java&#10;       ├── JwtKeyProvider.java&#10;       ├── InMemoryUserService.java&#10;       └── RsaKeyProperties.java&#10;src/main/resources/&#10;  └── application.yml&#10;```&#10;&#10;---&#10;&#10;## Actividades propuestas&#10;1. Revisar el código de configuración de seguridad (`SecurityConfig`) e identificar cómo se definen los endpoints públicos y protegidos.&#10;2. Explorar el flujo de login y analizar las claims del JWT emitido.&#10;3. Extender los scopes (`blueprints.read`, `blueprints.write`) para controlar otros endpoints de la API, del laboratorio P1 trabajado.&#10;4. Modificar el tiempo de expiración del token y observar el efecto.&#10;5. Documentar en Swagger los endpoints de autenticación y de negocio.&#10;&#10;---&#10;# REPORTE DE LABORATORIO&#10;---&#10;### INTEGRANTES:&#10;      - Laura Alejandra Venegas Piraban  &#10;      - Sergio Alejandro Idarraga Torres  &#10;&#10;## 1. Código de configuración de seguridad&#10;&#10;En el archivo `SecurityConfig.java`, se define la configuración de seguridad para la API mediante el método `filterChain(HttpSecurity http)`, anotado con `@Bean`. Este método construye la cadena de filtros de seguridad que determina qué rutas son públicas y cuáles requieren autenticación.&#10;&#10;&lt;div align=&quot;center&quot;&gt;&#10;  &lt;img src=&quot;img/filterChain.png&quot; alt=&quot;filterChain&quot; style=&quot;max-width: 400px; display: block; margin: 0 auto;&quot; /&gt;&#10;&lt;/div&gt;&#10;&#10;### Endpoints públicos (sin autenticación)&#10;&#10;```java&#10;.requestMatchers(&quot;/actuator/health&quot;, &quot;/auth/login&quot;).permitAll()&#10;.requestMatchers(&quot;/v3/api-docs/**&quot;, &quot;/swagger-ui/**&quot;, &quot;/swagger-ui.html&quot;).permitAll()&#10;```&#10;&#10;Estas líneas declaran que los siguientes recursos son accesibles **sin ningún token**:&#10;&#10;| Ruta | Propósito |&#10;|------|-----------|&#10;| `/auth/login` | Endpoint didáctico para emitir tokens JWT |&#10;| `/actuator/health` | Verificación del estado de la aplicación |&#10;| `/v3/api-docs/**`, `/swagger-ui/**`, `/swagger-ui.html` | Documentación OpenAPI / Swagger UI |&#10;&#10;### Endpoints protegidos (requieren token JWT)&#10;&#10;```java&#10;.requestMatchers(&quot;/api/**&quot;).hasAnyAuthority(&quot;SCOPE_blueprints.read&quot;, &quot;SCOPE_blueprints.write&quot;)&#10;.anyRequest().authenticated()&#10;```&#10;&#10;- Todos los endpoints bajo `/api/**` requieren que el token JWT contenga al menos uno de los scopes: `blueprints.read` (lectura) o `blueprints.write` (escritura). Spring Security prefija automáticamente `SCOPE_` al comparar las autoridades del token.&#10;- Cualquier otra ruta no listada explícitamente exige que el usuario esté autenticado (token válido), pero sin exigir un scope específico.&#10;&#10;### Deshabilitación de CSRF&#10;&#10;```java&#10;.csrf(csrf -&gt; csrf.disable())&#10;```&#10;&#10;Se deshabilita la protección CSRF porque la API es **stateless** (no usa sesiones ni cookies de sesión). Los tokens JWT se envían en el encabezado `Authorization`, lo que ya protege contra este tipo de ataque.&#10;&#10;### Configuración como Resource Server&#10;&#10;```java&#10;.oauth2ResourceServer(oauth2 -&gt; oauth2.jwt(Customizer.withDefaults()))&#10;```&#10;&#10;Indica a Spring Security que esta aplicación actúa como un **OAuth2 Resource Server**: toda petición a rutas protegidas debe incluir un token JWT válido en el encabezado `Authorization: Bearer &lt;token&gt;`. El token se valida usando la clave pública RSA configurada en `JwtDecoder`.&#10;&#10;### Codificación de contraseñas y claves RSA&#10;&#10;```java&#10;@Bean PasswordEncoder passwordEncoder() { return new BCryptPasswordEncoder(); }&#10;&#10;@Bean JwtDecoder jwtDecoder(JwtKeyProvider keyProvider) { ... }  // valida tokens con clave pública RSA&#10;@Bean JwtEncoder jwtEncoder(JwtKeyProvider keyProvider) { ... }  // firma tokens con clave privada RSA&#10;```&#10;&#10;- Las contraseñas de los usuarios se almacenan hasheadas con **BCrypt**.&#10;- Los tokens se firman con el algoritmo **RS256** (RSA + SHA-256): el servidor firma con la clave privada y verifica con la clave pública.&#10;&#10;---&#10;&#10;## 2. Flujo de login y claims del JWT emitido&#10;&#10;### Flujo de autenticación&#10;&#10;El endpoint `POST /auth/login` en `AuthController.java` implementa el flujo didáctico de emisión de tokens:&#10;&#10;```&#10;Cliente  ──POST /auth/login {username, password}──►  AuthController&#10;                                                           │&#10;                                                    InMemoryUserService.isValid()&#10;                                                     (BCrypt hash check)&#10;                                                           │&#10;                                              ┌────────────┴────────────┐&#10;                                           válido                   inválido&#10;                                              │                         │&#10;                                     Construye JwtClaimsSet      HTTP 401&#10;                                     Firma con RS256 (JwtEncoder)&#10;                                              │&#10;                                     Retorna TokenResponse&#10;                                     { access_token, token_type, expires_in }&#10;```&#10;&#10;**Paso a paso:**&#10;&#10;1. El cliente envía `username` y `password` en el cuerpo JSON.&#10;2. `InMemoryUserService.isValid()` busca el usuario en el mapa en memoria y compara la contraseña recibida con el hash BCrypt almacenado.&#10;3. Si la validación falla, se retorna `HTTP 401` con `{&quot;error&quot;: &quot;invalid_credentials&quot;}`.&#10;4. Si es exitosa, se construye el conjunto de claims y se firma el token con la clave privada RSA.&#10;5. Se retorna un objeto con el token, el tipo `Bearer` y el tiempo de expiración.&#10;&#10;### Usuarios disponibles (en memoria)&#10;&#10;| Usuario | Contraseña |&#10;|---------|------------|&#10;| `student` | `student123` |&#10;| `assistant` | `assistant123` |&#10;&#10;Ambos usuarios reciben **exactamente los mismos scopes** al autenticarse.&#10;&#10;### Claims del JWT emitido&#10;&#10;```java&#10;JwtClaimsSet claims = JwtClaimsSet.builder()&#10;    .issuer(props.issuer())          // quién emitió el token (configurado en application.yml)&#10;    .issuedAt(now)                   // timestamp de emisión&#10;    .expiresAt(now.plusSeconds(ttl)) // timestamp de expiración (por defecto 3600 s = 1 hora)&#10;    .subject(req.username())         // nombre del usuario autenticado&#10;    .claim(&quot;scope&quot;, &quot;blueprints.read blueprints.write&quot;)  // permisos otorgados&#10;    .build();&#10;```&#10;&#10;| Claim | Valor | Descripción |&#10;|-------|-------|-------------|&#10;| `iss` | valor de `blueprints.security.issuer` en `application.yml` | Emisor del token |&#10;| `iat` | timestamp actual | Momento en que se emitió el token |&#10;| `exp` | `iat + tokenTtlSeconds` (default 3600) | Momento de expiración |&#10;| `sub` | `&quot;student&quot;` o `&quot;assistant&quot;` | Sujeto / usuario autenticado |&#10;| `scope` | `&quot;blueprints.read blueprints.write&quot;` | Scopes autorizados (separados por espacio) |&#10;&#10;### Cabecera del JWT (Header)&#10;&#10;```java&#10;JwsHeader jws = JwsHeader.with(() -&gt; &quot;RS256&quot;).build();&#10;```&#10;&#10;| Campo | Valor | Descripción |&#10;|-------|-------|-------------|&#10;| `alg` | `RS256` | Algoritmo de firma: RSA con SHA-256 |&#10;| `typ` | `JWT` | Tipo de token |&#10;&#10;### Ejemplo de token decodificado&#10;&#10;Un token emitido por este sistema, decodificado en [jwt.io](https://jwt.io), tendría la siguiente estructura:&#10;&#10;**Header:**&#10;```json&#10;{&#10;  &quot;alg&quot;: &quot;RS256&quot;,&#10;  &quot;typ&quot;: &quot;JWT&quot;&#10;}&#10;```&#10;&#10;**Payload:**&#10;```json&#10;{&#10;  &quot;iss&quot;: &quot;blueprints-api&quot;,&#10;  &quot;iat&quot;: 1700000000,&#10;  &quot;exp&quot;: 1700003600,&#10;  &quot;sub&quot;: &quot;student&quot;,&#10;  &quot;scope&quot;: &quot;blueprints.read blueprints.write&quot;&#10;}&#10;```&#10;&#10;&gt; El token **no contiene** la contraseña ni información sensible. Cualquier receptor puede leer el payload, pero solo el servidor puede **verificar su firma** usando la clave pública RSA, garantizando su autenticidad e integridad.&#10;&#10;---&#10;&#10;## Lecturas recomendadas&#10;- [Spring Security Reference – OAuth2 Resource Server](https://docs.spring.io/spring-security/reference/servlet/oauth2/resource-server/index.html)&#10;- [Spring Boot – Securing Web Applications](https://spring.io/guides/gs/securing-web/)&#10;- [JSON Web Tokens – jwt.io](https://jwt.io/introduction)&#10;&#10;---&#10;&#10;## Licencia&#10;Proyecto educativo con fines académicos – Escuela Colombiana de Ingeniería Julio Garavito." />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>